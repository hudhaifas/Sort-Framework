/*
 * Copyright (C) 2019 Hudhaifa Shatnawi
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.hudhaifa.sortframework.app;

import com.hudhaifa.sortframework.core.AbstractSort;
import com.hudhaifa.sortframework.core.SortCanvas;
import com.hudhaifa.sortframework.core.Sorter;
import com.hudhaifa.sortframework.parallel.ParallelIMergeSort;
import com.hudhaifa.sortframework.parallel.ParallelMergeSort;
import com.hudhaifa.sortframework.sort.BubbleSort;
import com.hudhaifa.sortframework.sort.IMergeSort;
import com.hudhaifa.sortframework.sort.InsertionSort;
import com.hudhaifa.sortframework.sort.MergeSort;
import com.hudhaifa.sortframework.sort.ShuffleSort;
import com.hudhaifa.sortframework.util.ArrayUtil;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Box;

/**
 * Visualize sorting algorithms.
 * 
 * @author Hudhaifa Shatnawi <hudhaifa.shatnawi@gmail.com>
 * @version 1.0, Jul 16, 2019
 * @since sort-framework v1.1
 */
public class SortApp
        extends javax.swing.JFrame {

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Windows".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SortApp.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new SortApp().setVisible(true);
        });
    }

    /**
     * Creates new form SortApp
     */
    public SortApp() {
        this.sorters = new ArrayList<>();
        initComponents();
        initSorters();
        initSortersComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sortersPanel = new javax.swing.JPanel();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        resetMenuItem = new javax.swing.JMenuItem();
        takeOffMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sort Framework");

        sortersPanel.setLayout(new javax.swing.BoxLayout(sortersPanel, javax.swing.BoxLayout.Y_AXIS));

        fileMenu.setText("File");

        resetMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.CTRL_MASK));
        resetMenuItem.setText("Reset");
        resetMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(resetMenuItem);

        takeOffMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.CTRL_MASK));
        takeOffMenuItem.setText("Take Off");
        takeOffMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                takeOffMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(takeOffMenuItem);

        menuBar.add(fileMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(sortersPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 792, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(sortersPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 668, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Initialize sort algorithms instances
     */
    private void initSorters() {
        for (String sorterClass : linearSorters) {
            try {
                AbstractSort sorter = (AbstractSort) Class.forName(sorterClass).newInstance();
                SortCanvas canvas = new HColorCanvas();
                sorters.add(new Sorter(sorter, canvas));
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {
                Logger.getLogger(SortApp.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        for (String sorterClass : parallelSorters) {
            try {
                AbstractSort sorter = (AbstractSort) Class.forName(sorterClass).newInstance();
                SortCanvas canvas = new HColorCanvas();
                sorters.add(new Sorter(sorter, canvas));
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException ex) {
                Logger.getLogger(SortApp.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    /**
     * Appends sort algorithms components to the screen
     */
    private void initSortersComponents() {
        for (int i = 0; i < sorters.size(); i++) {
            Sorter sorter = sorters.get(i);
            sortersPanel.add(sorter);
            sortersPanel.add(getFiller());
        }
    }

    /**
     * Returns filler components for the Box layout
     * @return filler components for the Box layout
     */
    private Box.Filler getFiller() {
        return new Box.Filler(new Dimension(0, 10), new Dimension(0, 10), new Dimension(0, 10));
    }

    private void resetMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetMenuItemActionPerformed
        int[] arr = fill(ArrayUtil.FILL_RANDOM, 100000);
        sorters.forEach((sorter) -> {
            sorter.init(Arrays.copyOf(arr, arr.length));
        });
    }//GEN-LAST:event_resetMenuItemActionPerformed

    private void takeOffMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_takeOffMenuItemActionPerformed
        sorters.forEach((sorter) -> {
            sorter.startSort();
        });
    }//GEN-LAST:event_takeOffMenuItemActionPerformed

    /**
     * Fills the array in on of the following orders:
     * <ul>
     * <li>Reverse order (non-repeated elements)</li>
     * <li>Nearly sorted (non-repeated elements)</li>
     * <li>Randomized (non-repeated elements)</li>
     * <li>Randomized (repeated elements)</li>
     * </ul>
     *
     * @param strategy fill strategy
     * @param size array length
     * @return filled array
     * @see ArrayUtil
     */
    protected int[] fill(int strategy, int size) {
        switch (strategy) {
            case ArrayUtil.FILL_REVERSE:
                return ArrayUtil.reversed(size);

            case ArrayUtil.FILL_NEARLY_SORTED:
                return ArrayUtil.nearlySorted(size, 3);

            case ArrayUtil.FILL_REPEATED:
                return ArrayUtil.repeated(size, 15);

            case ArrayUtil.FILL_RANDOM:
            default:
                return ArrayUtil.random(size);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu fileMenu;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JMenuItem resetMenuItem;
    private javax.swing.JPanel sortersPanel;
    private javax.swing.JMenuItem takeOffMenuItem;
    // End of variables declaration//GEN-END:variables

    /**
     * List of all supported sort algorithms
     */
    private final List<Sorter> sorters;
    /**
     * List of supported linear sort algorithms
     */
    private final String[] linearSorters = new String[]{
        BubbleSort.class.getName(),
        IMergeSort.class.getName(),
        InsertionSort.class.getName(),
        MergeSort.class.getName(),
        ShuffleSort.class.getName()
    };
    /**
     * List of supported parallel sort algorithms
     */
    private final String[] parallelSorters = new String[]{
        ParallelIMergeSort.class.getName(),
        ParallelMergeSort.class.getName()
    };
}
